/*
 *  CsvJdbc - a JDBC driver for CSV files
 *  Copyright (C) 2008  Mario Frasca
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
options{
  STATIC = false;
  LOOKAHEAD = 1;
  IGNORE_CASE = true;
  JDK_VERSION = "1.3";
}
PARSER_BEGIN(ExpressionParser)
package org.relique.jdbc.csv;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.math.MathContext;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;
class NumericConstant extends Expression{
  Number value;
  public NumericConstant(Number d){
    value = d;
  }
  public Object eval(Map<String, Object> env){
    return value;
  }
  public String toString(){
    return value.toString();
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
}
class StringConstant extends Expression{
  String value;
  public StringConstant(String s){
    value = s;
  }
  public Object eval(Map<String, Object> env){
    return value;
  }
  public String toString(){
    return "'"+value+"'";
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
}
class NullConstant extends Expression{
  public Object eval(Map<String, Object> env){
    return null;
  }
  public String toString(){
    return "null";
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
}
class CurrentDateConstant extends Expression{
  ExpressionParser parent;
  public CurrentDateConstant(ExpressionParser parent){
    this.parent = parent;
  }
  public Object eval(Map<String, Object> env){
    return parent.getCurrentDate();
  }
  public String toString(){
    return "CURRENT_DATE";
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
}
class Placeholder extends Expression{
  public static int nextIndex = 1;
  private int index;
  public Placeholder(){
    index = nextIndex;
    nextIndex++;
  }
  public Object eval(Map<String, Object> env){
    return env.get("?" + index);
  }
  public String toString(){
    return "?";
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
}  
class ColumnName extends Expression{
  String columnName;
  public ColumnName(String columnName){
    this .columnName = columnName.toUpperCase();
  }
  public Object eval(Map<String, Object> env){
    return env.get(columnName);
  }
  public String toString(){
    return "["+columnName+"]";
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.add(columnName);
    return result;
  }
}
class SQLLowerFunction extends Expression{
  Expression expression;
  public SQLLowerFunction(Expression expression){
    this.expression = expression;
  }
  public Object eval(Map<String, Object> env){
    Object retval = expression.eval(env);
    if (retval != null)
      retval = retval.toString().toLowerCase();
    return retval;
  }
  public String toString(){
    return "LOWER("+expression+")";
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(expression.usedColumns());
    return result;
  }
}
class SQLRoundFunction extends Expression{
  Expression expression;
  public SQLRoundFunction(Expression expression){
    this.expression = expression;
  }
  public Object eval(Map<String, Object> env){
    Object retval = expression.eval(env);
    if (retval != null) {
      if (!(retval instanceof Number)) {
        try {
          retval = new Double(retval.toString());
        } catch(NumberFormatException e) {
          retval = null;
        }
      }
      if (retval != null) {
        if (!(retval instanceof Integer)) {
          double d = ((Number)retval).doubleValue();
          if (d < Integer.MIN_VALUE || d > Integer.MAX_VALUE)
	    retval = new Double(Math.round(d));
          else
	    retval = new Integer((int)Math.round(d));
        }
      }
    }
    return retval;
  }
  public String toString(){
    return "ROUND("+expression+")";
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(expression.usedColumns());
    return result;
  }
}
class SQLUpperFunction extends Expression{
  Expression expression;
  public SQLUpperFunction(Expression expression){
    this.expression = expression;
  }
  public Object eval(Map<String, Object> env){
    Object retval = expression.eval(env);
    if (retval != null)
      retval = retval.toString().toUpperCase();
    return retval;
  }
  public String toString(){
    return "UPPER("+expression+")";
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(expression.usedColumns());
    return result;
  }
}
abstract class AggregateFunction extends Expression{
  public abstract List<String> aggregateColumns();
  public abstract void processRow(Map<String, Object> env);
}
class SQLCountFunction extends AggregateFunction{
  Expression expression;
  int counter = 0;
  public SQLCountFunction(Expression expression){
    this.expression = expression;
  }
  public Object eval(Map<String, Object> env){
    Object o = env.get("@GROUPROWS");
    if (o != null) {
      /*
       * The count is the number of rows grouped together
       * by the GROUP BY clause.
       */
      List groupRows = (List)o;
      return Integer.valueOf(groupRows.size());
    }
    return Integer.valueOf(counter);
  }
  public String toString(){
    return "COUNT("+expression+")";
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
  public List<String> aggregateColumns(){
    List<String> result = new LinkedList<String>();
    if (!(expression instanceof AsteriskExpression))
      result.addAll(expression.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.add(this);
    return result;
  }
  public void processRow(Map<String, Object> env){
    if (expression instanceof AsteriskExpression) {
      counter++;
    } else {
      /*
       * Only count non-null values.
       */
      Object o = expression.eval(env);
      if (o != null)
        counter++;
    }
  }
}
class SQLMaxFunction extends AggregateFunction{
  Expression expression;
  Object max = null;
  public SQLMaxFunction(Expression expression){
    this.expression = expression;
  }
  public Object eval(Map<String, Object> env){
    Object o = env.get("@GROUPROWS");
    if (o != null) {
      /*
       * Find the maximum from the rows grouped together
       * by the GROUP BY clause.
       */
      List groupRows = (List)o;
      Object maxInGroup = null;
      for (int i = 0; i < groupRows.size(); i++) {
        o = expression.eval((Map)groupRows.get(i));
        if (o != null){
          if (maxInGroup == null || ((Comparable)maxInGroup).compareTo(o) < 0)
            maxInGroup = o;
        }
      }
      return maxInGroup;
    }
    return max;
  }
  public String toString(){
    return "MAX("+expression+")";
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
  public List<String> aggregateColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(expression.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.add(this);
    return result;
  }
  public void processRow(Map<String, Object> env){
    /*
     * Only consider non-null values.
     */
    Object o = expression.eval(env);
    if (o != null){
      if (max == null || ((Comparable)max).compareTo(o) < 0)
        max = o;
    }
  }
}
class SQLMinFunction extends AggregateFunction{
  Expression expression;
  Object min = null;
  public SQLMinFunction(Expression expression){
    this.expression = expression;
  }
  public Object eval(Map<String, Object> env){
    Object o = env.get("@GROUPROWS");
    if (o != null) {
      /*
       * Find the minimum from the rows grouped together
       * by the GROUP BY clause.
       */
      List groupRows = (List)o;
      Object minInGroup = null;
      for (int i = 0; i < groupRows.size(); i++) {
        o = expression.eval((Map)groupRows.get(i));
        if (o != null){
          if (minInGroup == null || ((Comparable)minInGroup).compareTo(o) > 0)
            minInGroup = o;
        }
      }
      return minInGroup;
    }
    return min;
  }
  public String toString(){
    return "MIN("+expression+")";
  }
  public List<String> usedColumns(){
    return new LinkedList<String>();
  }
  public List<String> aggregateColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(expression.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.add(this);
    return result;
  }
  public void processRow(Map<String, Object> env){
    /*
     * Only consider non-null values.
     */
    Object o = expression.eval(env);
    if (o != null){
      if (min == null || ((Comparable)min).compareTo(o) > 0)
        min = o;
    }
  }
}
class QueryEnvEntry extends Expression{
  String key;
  Expression expression;
  public QueryEnvEntry(String fieldName){
    this .key = fieldName.toUpperCase();
    this .expression = new ColumnName(fieldName);
  }
  public QueryEnvEntry(String fieldName, Expression exp){
    this .key = fieldName.toUpperCase();
    this .expression = exp;
  }
  public Object eval(Map<String, Object> env){
    return expression.eval(env);
  }
  public String toString(){
    return key+": "+expression.toString();
  }
}
class OrderByEntry extends Expression{
  String order;
  Expression expression;
  public OrderByEntry(Expression expression, String order){
    this.order = order;
    this.expression = expression;
  }
}
class BinaryOperation extends Expression{
  private static final long MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000;
  char op;
  Expression left, right;
  public BinaryOperation(char op, Expression left, Expression right){
    this .op = op;
    this .left = left;
    this .right = right;
  }
  public Object eval(Map<String, Object> env){
    Object leftEval = left.eval(env);
    Object rightEval = right.eval(env);
    try {
      Integer leftInt = (Integer)leftEval;
      BigInteger bil = new BigInteger(leftInt.toString());
      Integer rightInt = (Integer)rightEval;
      BigInteger bir = new BigInteger(rightInt.toString());
      if (op == '+')return new Integer(bil.add(bir).toString());
      if (op == '-')return new Integer(bil.subtract(bir).toString());
      if (op == '*')return new Integer(bil.multiply(bir).toString());
      if (op == '/')return new Integer(bil.divide(bir).toString());
    }
    catch (ClassCastException e){}try {
      Number leftN = (Number)leftEval;
      BigDecimal bdl = new BigDecimal(leftN.toString());
      Number rightN = (Number)rightEval;
      BigDecimal bdr = new BigDecimal(rightN.toString());
      if (op == '+')return new Double(bdl.add(bdr).toString());
      if (op == '-')return new Double(bdl.subtract(bdr).toString());
      if (op == '*')return new Double(bdl.multiply(bdr).toString());
      MathContext mc = new MathContext("precision=14 roundingMode=HALF_UP");
      if (op == '/')return new Double(bdl.divide(bdr, mc.getPrecision(), mc.getRoundingMode()).toString());
    }
    catch (ClassCastException e){}try {
      if (op == '+' && leftEval instanceof Date){
        Date leftD = (Date)leftEval;
        if (rightEval instanceof Time) {
          Time rightT = (Time)rightEval;
          Expression stringConverter = new ColumnName("@StringConverter");
          StringConverter sc = (StringConverter) stringConverter.eval(env);
          return sc.parseTimestamp(leftD.toString() + " " + rightT.toString());
        } else {
          Integer rightInt = (Integer)rightEval;
	  return incrementDate(leftD, rightInt.intValue());
        }
      } else if (op == '+' && rightEval instanceof Date){
        Date rightD = (Date)rightEval;
        if (leftEval instanceof Time) {
          Time leftT = (Time)leftEval;
          Expression stringConverter = new ColumnName("@StringConverter");
          StringConverter sc = (StringConverter) stringConverter.eval(env);
          return sc.parseTimestamp(rightD.toString() + " " + leftT.toString());
        } else {
          Integer leftInt = (Integer)leftEval;
	  return incrementDate(rightD, leftInt.intValue());
        }
      } else if (op == '-' && leftEval instanceof Date && rightEval instanceof Integer){
	  return incrementDate((Date)leftEval, -((Integer)rightEval).intValue());
      } else if (op == '-' && (leftEval instanceof Date || rightEval instanceof Date)){
	  if (!(leftEval instanceof Date)) {
            Expression stringConverter = new ColumnName("@StringConverter");
            StringConverter sc = (StringConverter) stringConverter.eval(env);
            leftEval = sc.parseDate(leftEval.toString());
	  }
	  if (!(rightEval instanceof Date)) {
            Expression stringConverter = new ColumnName("@StringConverter");
            StringConverter sc = (StringConverter) stringConverter.eval(env);
            rightEval = sc.parseDate(rightEval.toString());
	  }
	  if (leftEval != null && rightEval != null) {
	    long nMillis = ((Date)leftEval).getTime() - ((Date)(rightEval)).getTime();
	    long nDays = (nMillis + MILLISECONDS_PER_DAY / 2) / MILLISECONDS_PER_DAY;
	    return new Integer((int)nDays);
	  }
      }
    }
    catch (ClassCastException e){}try {
      if (op == '+' || op == '-'){
        Timestamp leftD = (Timestamp)leftEval;
        long time = leftD.getTime();
        Number rightN = (Number)rightEval;
        BigDecimal bdr = new BigDecimal(rightN.toString());
        if (op == '+')return new Timestamp(time + bdr.longValue());
        if (op == '-')return new Timestamp(time - bdr.longValue());
      }
    }
    catch (ClassCastException e){}
    if(op == '+')return ""+leftEval+rightEval;
    return null;
  }
  private Date incrementDate(Date date, int nDays){
    long newTime = date.getTime() +
      nDays * MILLISECONDS_PER_DAY + MILLISECONDS_PER_DAY / 2;
    Date newDate = new Date(newTime);
    /* Remove any time component from calculated date */
    newDate = Date.valueOf(newDate.toString());
    return newDate;
  }
  public String toString(){
    return ""+op+" "+left+" "+right;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(left.usedColumns());
    result.addAll(right.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.addAll(left.aggregateFunctions());
    result.addAll(right.aggregateFunctions());
    return result;
  }
}
abstract class LogicalExpression extends Expression{
  public boolean isTrue(Map<String, Object> env){
    return false;
  }
}
class ParsedExpression extends LogicalExpression{
  public Expression content;
  private Map<String, Object> placeholders;
  public ParsedExpression(Expression left){
    content = left;
    placeholders = new HashMap<String, Object>();
  }
  public boolean isTrue(Map<String, Object> env){
    if(placeholders != null) {
      Map<String, Object> useThisEnv = new HashMap<String, Object>();
      useThisEnv.putAll(env);
      useThisEnv.putAll(placeholders);
      env = useThisEnv;
    } 
    return ((LogicalExpression)content).isTrue(env);
  }
  public Object eval(Map<String, Object> env){
    if(placeholders != null) {
      Map<String, Object> useThisEnv = new HashMap<String, Object>();
      useThisEnv.putAll(env);
      useThisEnv.putAll(placeholders);
      env = useThisEnv;
    } 
    return content.eval(env);
  }
  public String toString(){
    return content.toString();
  }
  public List<String> usedColumns(){
    return content.usedColumns();
  }
  public List<AggregateFunction> aggregateFunctions(){
    return content.aggregateFunctions();
  }
  public int getPlaceholdersCount(){
    return Placeholder.nextIndex - 1;
  }
  public void setPlaceholdersValues(Object[] values){
    for(int i=1; i<values.length; i++){
      placeholders.put("?" + i, values[i]);
    }
  }
}
class NotExpression extends LogicalExpression{
  LogicalExpression content;
  public NotExpression(LogicalExpression arg){
    this .content = arg;
  }
  public boolean isTrue(Map<String, Object> env){
    return !content.isTrue(env);
  }
  public String toString(){
    return "NOT "+content;
  }
  public List<String> usedColumns(){
    return content.usedColumns();
  }
  public List<AggregateFunction> aggregateFunctions(){
    return content.aggregateFunctions();
  }
}
class OrExpression extends LogicalExpression{
  LogicalExpression left, right;
  public OrExpression(LogicalExpression left, LogicalExpression right){
    this .left = left;
    this .right = right;
  }
  public boolean isTrue(Map<String, Object> env){
    return left.isTrue(env) || right.isTrue(env);
  }
  public String toString(){
    return "OR "+left+" "+right;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(left.usedColumns());
    result.addAll(right.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.addAll(left.aggregateFunctions());
    result.addAll(right.aggregateFunctions());
    return result;
  }
}
class AndExpression extends LogicalExpression{
  LogicalExpression left, right;
  public AndExpression(LogicalExpression left, LogicalExpression right){
    this .left = left;
    this .right = right;
  }
  public boolean isTrue(Map<String, Object> env){
    return left.isTrue(env) && right.isTrue(env);
  }
  public String toString(){
    return "AND "+left+" "+right;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(left.usedColumns());
    result.addAll(right.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.addAll(left.aggregateFunctions());
    result.addAll(right.aggregateFunctions());
    return result;
  }
}
class RelopExpression extends LogicalExpression{
  String op;
  Expression left, right;
  public RelopExpression(String op, Expression left, Expression right){
    this .op = op;
    this .left = left;
    this .right = right;
  }
  public boolean isTrue(Map<String, Object> env){
    Comparable leftValue = (Comparable)left.eval(env);
    Comparable rightValue = (Comparable)right.eval(env);
    boolean result = false;
    Integer leftComparedToRightObj = null;
    try {
      leftComparedToRightObj = new Integer(leftValue.compareTo(rightValue));
    }
    catch (ClassCastException e){}try {
      if (leftComparedToRightObj == null && leftValue instanceof Date){
        Expression stringConverter = new ColumnName("@StringConverter");
        StringConverter sc = (StringConverter) stringConverter.eval(env);
        Date date = sc.parseDate(rightValue.toString());
        leftComparedToRightObj = new Integer(leftValue.compareTo(date));
      }else if (leftComparedToRightObj == null && rightValue instanceof Date){
        Expression stringConverter = new ColumnName("@StringConverter");
        StringConverter sc = (StringConverter) stringConverter.eval(env);
        Date date = sc.parseDate(leftValue.toString());
        leftComparedToRightObj = new Integer(date.compareTo((Date)rightValue));
      }else{
        Double leftDouble = new Double(((Number)leftValue).toString());
        Double rightDouble = new Double(((Number)rightValue).toString());
        leftComparedToRightObj = new Integer(leftDouble.compareTo(rightDouble));
      }
    }
    catch (ClassCastException e){}catch (NumberFormatException e){}if (leftComparedToRightObj != null){
      int leftComparedToRight = leftComparedToRightObj.intValue();
      if (leftValue != null && rightValue != null){
        if (op.equals("=")){
          result = leftComparedToRight == 0;
        }
        else if (op.equals("<>") || op.equals("!=")){
          result = leftComparedToRight != 0;
        }
        else if (op.equals(">")){
          result = leftComparedToRight>0;
        }
        else if (op.equals("<")){
          result = leftComparedToRight<0;
        }
        else if (op.equals("<=") || op.equals("=<")){
          result = leftComparedToRight <= 0;
        }
        else if (op.equals(">=") || op.equals("=>")){
          result = leftComparedToRight >= 0;
        }
      }
    }
    return result;
  }
  public String toString(){
    return op+" "+left+" "+right;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(left.usedColumns());
    result.addAll(right.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.addAll(left.aggregateFunctions());
    result.addAll(right.aggregateFunctions());
    return result;
  }
}
class BetweenExpression extends LogicalExpression{
  Expression obj, left, right;
  public BetweenExpression(Expression obj, Expression left, Expression right){
    this .obj = obj;
    this .left = left;
    this .right = right;
  }
  public boolean isTrue(Map<String, Object> env){
    Comparable leftValue = (Comparable)left.eval(env);
    Comparable rightValue = (Comparable)right.eval(env);
    Comparable objValue = (Comparable)obj.eval(env);
    boolean result = true;
    try {
      if (objValue.compareTo(leftValue)<0)result = false;
      if (objValue.compareTo(rightValue)>0)result = false;
    }
    catch (ClassCastException e){}return result;
  }
  public String toString(){
    return "B "+obj+" "+left+" "+right;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(obj.usedColumns());
    result.addAll(left.usedColumns());
    result.addAll(right.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.addAll(obj.aggregateFunctions());
    result.addAll(left.aggregateFunctions());
    result.addAll(right.aggregateFunctions());
    return result;
  }
}
class IsNullExpression extends LogicalExpression{
  Expression arg;
  public IsNullExpression(Expression arg){
    this .arg = arg;
  }
  public boolean isTrue(Map<String, Object> env){
    Object o = arg.eval(env);
    return (o == null);
  }
  public String toString(){
    return "N "+arg;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(arg.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.addAll(arg.aggregateFunctions());
    return result;
  }
}
class LikeExpression extends LogicalExpression{
  Expression arg1, arg2;
  public LikeExpression(Expression arg1, Expression arg2){
    this .arg1 = arg1;
    this .arg2 = arg2;
  }
  public boolean isTrue(Map<String, Object> env){
    Object left = arg1.eval(env);
    Object right = arg2.eval(env);
    boolean result = false;
    if (left != null && right != null)
      result = LikePattern.matches(right.toString(), left.toString());
    return result;
  }
  public String toString(){
    return "L "+arg1+" "+arg2;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    result.addAll(arg1.usedColumns());
    result.addAll(arg2.usedColumns());
    return result;
  }
  public List<AggregateFunction> aggregateFunctions(){
    List<AggregateFunction> result = new LinkedList<AggregateFunction>();
    result.addAll(arg1.aggregateFunctions());
    result.addAll(arg2.aggregateFunctions());
    return result;
  }
}
class AsteriskExpression extends LogicalExpression{
  String expression;
  public AsteriskExpression(String expression){
    this.expression = expression;
  }
  public boolean isTrue(Map<String, Object> env){
    return false;
  }
  public String toString(){
    return expression;
  }
  public List<String> usedColumns(){
    List<String> result = new LinkedList<String>();
    return result;
  }
}
class ParsedStatement{
  List<ParsedExpression> queryEntries;
  boolean isDistinct;
  String tableName;
  String tableAlias;
  ParsedExpression whereClause;
  List<ParsedExpression> groupByEntries;
  List<ParsedExpression> orderByEntries;
  int limit, offset;
  public ParsedStatement(List<ParsedExpression> queryEntries, boolean isDistinct,
    String tableName, String tableAlias,
    ParsedExpression whereClause,
    List<ParsedExpression> groupByEntries,
    List<ParsedExpression> orderByEntries,
    int limit, int offset){
    this.queryEntries = queryEntries;
    this.isDistinct = isDistinct;
    this.tableName = tableName;
    this.tableAlias = tableAlias;
    this.whereClause = whereClause;
    this.groupByEntries = groupByEntries;
    this.orderByEntries = orderByEntries;
    this.limit = limit;
    this.offset = offset;
  }
}
public class ExpressionParser{
  ParsedExpression content;
  List<ParsedExpression> queryEntries;
  boolean isDistinct;
  String tableName;
  String tableAlias;
  List<ParsedExpression> groupByEntries;
  List<ParsedExpression> orderByEntries;
  int limit;
  int offset;
  Date currentDate;
  public void parseLogicalExpression()throws ParseException{
    content = logicalExpression();
  }
  public void parseGroupByEntry()throws ParseException{
    content = groupByEntry();
  }
  public void parseOrderByEntry()throws ParseException{
    content = orderByEntry();
  }
  public void parseQueryEnvEntry()throws ParseException{
    content = queryEnvEntry();
  }
  public void parseSelectStatement()throws ParseException{
    /* Reset prepared statement place-holder counter */
    Placeholder.nextIndex = 1;
    ParsedStatement parsedStatement = selectStatement();
    queryEntries = parsedStatement.queryEntries;
    isDistinct = parsedStatement.isDistinct;
    tableName = parsedStatement.tableName;
    tableAlias = parsedStatement.tableAlias;
    content = parsedStatement.whereClause;
    groupByEntries = parsedStatement.groupByEntries;
    orderByEntries = parsedStatement.orderByEntries;
    limit = parsedStatement.limit;
    offset = parsedStatement.offset;
  }
  public Object eval(Map<String, Object> env){
    return content.eval(env);
  }
  public String toString(){
    return ""+content;
  }
  public Date getCurrentDate(){
    if (currentDate == null){
      currentDate = new Date(System.currentTimeMillis());
      /* Remove any time component from the date */
      currentDate = Date.valueOf(currentDate.toString());
    }
    return currentDate;
  }
}
PARSER_END(ExpressionParser)
SKIP:{
  " "
  | "\t"
  | "\r"
  | "\n"
}
TOKEN:{
  <SELECT:"SELECT">
}
TOKEN:{
  <DISTINCT:"DISTINCT">
}
TOKEN:{
  <COMMA:",">
}
TOKEN:{
  <UNSIGNEDINT:<DIGITS>>
}
TOKEN:{
  <UNSIGNEDNUMBER:<DIGITS> (<EXPONENT>)?
  | <DIGITS>"."<DIGITS> (<EXPONENT>)?
  | "."<DIGITS> (<EXPONENT>)?
  | <DIGITS>"." (<EXPONENT>)?>
}
TOKEN:{
  <#DIGITS:(["0"-"9"])+>
}
TOKEN:{
  <#EXPONENT: ["e","E"] (["+","-"])? <DIGITS>>
}
TOKEN:{
  <NULL:"NULL">
}
TOKEN:{
  <CURRENT_DATE:"CURRENT_DATE">
}
TOKEN:{
  <AND:"AND">
}
TOKEN:{
  <OR:"OR">
}
TOKEN:{
  <NOT:"NOT">
}
TOKEN:{
  <IS:"IS">
}
TOKEN:{
  <AS:"AS">
}
TOKEN:{
  <LIKE:"LIKE">
}
TOKEN:{
  <BETWEEN:"BETWEEN">
}
TOKEN:{
  <PLACEHOLDER:"?">
}
TOKEN:{
  <ASC:"ASC">
}
TOKEN:{
  <DESC:"DESC">
}
TOKEN:{
  <LOWER:"LOWER">
}
TOKEN:{
  <ROUND:"ROUND">
}
TOKEN:{
  <UPPER:"UPPER">
}
TOKEN:{
  <COUNT:"COUNT">
}
TOKEN:{
  <MAX:"MAX">
}
TOKEN:{
  <MIN:"MIN">
}
TOKEN:{
  /*
   * Change to IN_TABLE state after parsing "FROM" keyword.
   */
  <FROM:"FROM"> : IN_TABLE
}
TOKEN:{
  <WHERE:"WHERE">
}
TOKEN:{
  <GROUP:"GROUP">
}
TOKEN:{
  <ORDER:"ORDER">
}
TOKEN:{
  <BY:"BY">
}
TOKEN:{
  <LIMIT:"LIMIT">
}
TOKEN:{
  <OFFSET:"OFFSET">
}
TOKEN:{
  <NAME:(["0"-"9", "A"-"Z", "a"-"z", "_", "."])+>
}
TOKEN:{
  <STRING:"'"(~["'"])*"'">
}
TOKEN:{
  <RELOP:(">"
  | "<"
  | ">="
  | "<="
  | "<>"
  | "="
  | "!=")>
}
TOKEN:{
  <ASTERISK:"*">
}
TOKEN:{
  <NAMEASTERISK:<NAME>".*">
}
TOKEN:{
  <MINUS:"-">
}
TOKEN:{
  <PLUS:"+">
}
TOKEN:{
  <DIVIDE:"/">
}
TOKEN:{
  <OPENPARENTHESIS:"(">
}
TOKEN:{
  <CLOSEPARENTHESIS:")">
}
<IN_TABLE> SKIP:{
  " "
  | "\t"
  | "\r"
  | "\n"
}
/*
 * Tablename is a sequence of non-whitespace or double-quoted
 * string when in IN_TABLE state.
 * Switch back to DEFAULT state after parsing table name.
 */
<IN_TABLE> TOKEN:{
  <TABLENAME:(~[" ", "\t", "\r", "\n"])+> : DEFAULT
}
<IN_TABLE> TOKEN:{
  <QUOTEDTABLENAME:"\""(~["\""])+"\""> : DEFAULT
}
/*
 * See http://www.engr.mun.ca/~theo/JavaCC-FAQ/javacc-faq-moz.htm
 * 3.19  How do I throw a ParseException instead of a TokenMgrError?
 */
<*> TOKEN:{
  <UNEXPECTED_CHAR: ~[]>
}
ParsedExpression logicalExpression():{
  LogicalExpression left;
}
{
  left = logicalOrExpression(){
    return new ParsedExpression(left);
  }
}
ParsedExpression groupByEntry():{
  Expression left;
}
{
  left = binaryOperation(){
    return new ParsedExpression(left);
  }
}
ParsedExpression orderByEntry():{
  Expression left;
  String order;
  Token t;
}
{
  {order = "ASC";}
  left = binaryOperation()(t=<ASC>{order=t.image;}|t=<DESC>{order=t.image;})?{
    return new ParsedExpression(new OrderByEntry(left, order));
  }
}
ParsedStatement selectStatement():{
  List<ParsedExpression> result;
  ParsedExpression expr;
  boolean isDistinct;
  String tableName;
  String tableAlias;
  ParsedExpression whereClause, entry;
  List<ParsedExpression> groupByEntries;
  List<ParsedExpression> orderByEntries;
  int limit, offset;
  Token t;
}
{
  {
    result = new LinkedList<ParsedExpression>();
    isDistinct = false;
    tableName = null;
    tableAlias = null;
    whereClause = null;
    groupByEntries = new LinkedList<ParsedExpression>();
    orderByEntries = new LinkedList<ParsedExpression>();
    limit = -1;
    offset = 0;
  }
  <SELECT>
  (<DISTINCT>{isDistinct = true;})?
  expr = queryEnvEntry(){result.add(expr);}(<COMMA>expr = queryEnvEntry(){result.add(expr);})*
  (
    <FROM>(t=<QUOTEDTABLENAME>|t=<TABLENAME>){tableName = StringConverter.removeQuotes(t.image);}((<AS>)?t=<NAME>{tableAlias = t.image.toUpperCase();})?
    (<WHERE>whereClause = logicalExpression())?
    (<GROUP><BY>entry = groupByEntry(){groupByEntries.add(entry);}(<COMMA>entry = groupByEntry(){groupByEntries.add(entry);})*)?
    (<ORDER><BY>entry = orderByEntry(){orderByEntries.add(entry);}(<COMMA>entry = orderByEntry(){orderByEntries.add(entry);})*)?
    (<LIMIT>t=<UNSIGNEDINT>{limit = Integer.parseInt(t.image);}(<OFFSET>t=<UNSIGNEDINT>{offset = Integer.parseInt(t.image);})?)?
  )?
  <EOF>{
    return new ParsedStatement(result, isDistinct, tableName, tableAlias, whereClause, groupByEntries, orderByEntries, limit, offset);
  }
}
ParsedExpression queryEnvEntry():{
  Expression expression, alias, result, asterisk;
  Token t;
}
{
  {
    alias = null;
  }
  (expression = binaryOperation()((<AS>)?alias = columnName())? {
    if (alias != null)
      result = new QueryEnvEntry(((ColumnName)alias).columnName, expression);
    else if (expression instanceof ColumnName)
      result = new QueryEnvEntry(((ColumnName)expression).columnName, expression);
    else
      result = new QueryEnvEntry(expression.toString(), expression);
    return new ParsedExpression(result);
  }
  )
  | (t=<ASTERISK>|t=<NAMEASTERISK>){
      asterisk = new AsteriskExpression(t.image);
      return new ParsedExpression(new QueryEnvEntry(t.image, asterisk));
  }

}
LogicalExpression logicalOrExpression():{
  LogicalExpression left, right;
}
{
  left = logicalAndExpression()(<OR>right = logicalAndExpression(){
    left = new OrExpression(left, right);
  }
  )*{
    return left;
  }
}
LogicalExpression logicalAndExpression():{
  LogicalExpression left, right;
}
{
  left = logicalUnaryExpression()(<AND>right = logicalUnaryExpression(){
    left = new AndExpression(left, right);
  }
  )*{
    return left;
  }
}
LogicalExpression logicalUnaryExpression():{
  LogicalExpression arg;
}
{
  <NOT>arg = logicalUnaryExpression(){
    return new NotExpression(arg);
  }
  | <OPENPARENTHESIS>arg = logicalOrExpression()<CLOSEPARENTHESIS>{
    return arg;
  }
  | arg = relationalExpression(){
    return arg;
  }
}
LogicalExpression relationalExpression():{
  Expression arg1, arg2, arg3;
  String op;
  Token t;
}
{
  arg1 = binaryOperation()(op = relOp()arg2 = binaryOperation(){
    return new RelopExpression(op, arg1, arg2);
  }
  | <BETWEEN>arg2 = binaryOperation()<AND>arg3 = binaryOperation(){
    return new BetweenExpression(arg1, arg2, arg3);
  }
  | <IS><NULL>{
    return new IsNullExpression(arg1);
  }
  | <LIKE>t = <STRING>{
    return new LikeExpression(arg1, new StringConstant(t.image.substring(1, t.image.length()-1)));
  }
  )
}
String relOp():{
  Token t;
}
{
  t = <RELOP>{
    return new String(t.image);
  }
}
char binAddOp():{
  Token t;
}
{
  (t = <PLUS>|t=<MINUS>){
    return t.image.charAt(0);
  }
}
char binMultiplyOp():{
  Token t;
}
{
  (t = <ASTERISK>|t=<DIVIDE>){
    return t.image.charAt(0);
  }
}
Expression countOperation():{
  Expression arg;
  Token t;
}
{
  (t=<ASTERISK>) {
    return new AsteriskExpression(t.image);
  }
  | arg = binaryOperation() {
    return arg;
  }
}
Expression binaryOperation():{
  Expression left, right;
  char op;
}
{
  left = multiplyOperation()(op = binAddOp()right = multiplyOperation(){
    left = new BinaryOperation(op, left, right);
  }
  )*{
    return left;
  }
}
Expression multiplyOperation():{
  Expression left, right;
  char op;
}
{
  left = simpleExpression()(op = binMultiplyOp()right = simpleExpression(){
    left = new BinaryOperation(op, left, right);
  }
  )*{
    return left;
  }
}
Expression simpleExpression():{
  Expression arg;
}
{
  <OPENPARENTHESIS> arg = binaryOperation() <CLOSEPARENTHESIS> {
    return arg;
  }
  | <UPPER> <OPENPARENTHESIS> arg = binaryOperation() <CLOSEPARENTHESIS> {
    return new SQLUpperFunction(arg);
  }
  | <LOWER> <OPENPARENTHESIS> arg = binaryOperation() <CLOSEPARENTHESIS> {
    return new SQLLowerFunction(arg);
  }
  | <ROUND> <OPENPARENTHESIS> arg = binaryOperation() <CLOSEPARENTHESIS> {
    return new SQLRoundFunction(arg);
  }
  | <COUNT> <OPENPARENTHESIS> arg = countOperation() <CLOSEPARENTHESIS> {
    return new SQLCountFunction(arg);
  }
  | <MAX> <OPENPARENTHESIS> arg = binaryOperation() <CLOSEPARENTHESIS> {
    return new SQLMaxFunction(arg);
  }
  | <MIN> <OPENPARENTHESIS> arg = binaryOperation() <CLOSEPARENTHESIS> {
    return new SQLMinFunction(arg);
  }
  | arg = columnName(){
    return arg;
  }
  | arg = numericConstant(){
    return arg;
  }
  | arg = stringConstant(){
    return arg;
  }
  | <NULL>{
    return new NullConstant();
  }
  | <CURRENT_DATE>{
    return new CurrentDateConstant(this);
  }
  | <PLACEHOLDER>{
    return new Placeholder();
  }
}
Expression columnName():{
  Token t;
}
{
  t = <NAME>{
    return new ColumnName(t.image);
  }
}
Expression numericConstant():{
  Token t;
  String sign;
}
{
  {sign="";}
  (t=<MINUS>{sign=t.image;})?
  (t = <UNSIGNEDNUMBER>|t = <UNSIGNEDINT>){
    Number value = null;
    try {
      value = new Integer(sign+t.image);
    }
    catch (NumberFormatException e){
      value = new Double(sign+t.image);
    }
    return new NumericConstant(value);
  }
}
Expression stringConstant():{
  String left, right;
}
{
  left = stringConstantAtom()(right = stringConstantAtom(){
    left = left+"'"+right;
  }
  )*{
    return new StringConstant(left);
  }
}
String stringConstantAtom():{
  Token t;
}
{
  t = <STRING>{
    return t.image.substring(1, t.image.length()-1);
  }
}

